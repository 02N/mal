(in types.ps\n) print

% concatenate: concatenate two strings or two arrays
% From Thinking in PostScript 1990 Reid
% (string1) (string2) concatenate string3
% array1 array2 concatenate array3
/concatenate { %def
    dup type 2 index type 2 copy ne { %if
        pop pop
        errordict begin (concatentate) typecheck end
    }{ %else
        /stringtype ne exch /arraytype ne and {
            errordict begin (concatenate) typecheck end
        } if
    } ifelse
    dup length 2 index length add 1 index type
    /arraytype eq { array }{ string } ifelse
    % stack: arg1 arg2 new
    dup 0 4 index putinterval
    % stack: arg1 arg2 new
    dup 4 -1 roll length 4 -1 roll putinterval
    % stack: new
} bind def

% reverse: array1 -> reverse -> array2
/reverse {
    [ exch
    aload % push array onto stack
    length -1 0 { 1 roll } for % reverse
    ]
} def

/pr_str {
    %(in pr_str\n) print
    /obj exch def
    /arraytype obj type eq { % if list
        % accumulate an array of strings
        (\()
        obj length 0 gt { %if any elements
            [
                obj {
                    pr_str
                } forall
            ]
            { concatenate ( ) concatenate } forall
            dup length 1 sub 0 exch getinterval % strip off final space
        } if
        (\)) concatenate
    }{ /integertype obj type eq { % if number
        /slen obj 10 idiv 1 add def
        obj 10 slen string cvrs
    }{ /stringtype obj type eq { % if string
        (") obj (") concatenate concatenate
    }{ null obj eq { % if nil
        (nil)
    }{ true obj eq { % if true
        (true)
    }{ false obj eq { % if false
        (false)
    }{ /nametype obj type eq { % if symbol
        obj obj length string cvs
    }{
        (<unknown>) 
    } ifelse } ifelse } ifelse } ifelse } ifelse } ifelse } ifelse

    %(pr_str2 stack vvv\n) print
    %pstack
    %(pr_str2 stack ^^^\n) print
} def


% list operations
/_first { 0 get } def
/_rest { dup length 1 sub 1 exch getinterval } def
/_nth { get } def


%
% Env implementation
%
/env_new { 1 dict begin
    /outer exch def
    << 
        /__outer__ outer
    >>
end } def

/env_find { 2 dict begin
    /key exch def
    /env exch def
    env key known { %if key in env
        env
    }{ env /__outer__ get null ne { %elseif __outer__ not null
        env /__outer__ get   key env_find
    }{ %else
        null
    } ifelse } ifelse
end } def

/env_set { 3 dict begin
    /func dup xcheck def
    /val exch cvlit def
    /key exch def
    /env exch def
    env key val func { cvx } if put
    val func { cvx } if
end } def

/env_get { 2 dict begin
    /key exch def
    /env exch def
    env key env_find
    dup null eq {
        (Error: ') print key 99 string cvs print (' not found\n) print
        error
    }{
        key get
    } ifelse
end } def
