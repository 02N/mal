(in types.ps\n) print

/MAX_SYM_SIZE 256

% concatenate: concatenate two strings or two arrays
% From Thinking in PostScript 1990 Reid
% (string1) (string2) concatenate string3
% array1 array2 concatenate array3
/concatenate { %def
    dup type 2 index type 2 copy ne { %if
        pop pop
        errordict begin (concatentate) typecheck end
    }{ %else
        /stringtype ne exch /arraytype ne and {
            errordict begin (concatenate) typecheck end
        } if
    } ifelse
    dup length 2 index length add 1 index type
    /arraytype eq { array }{ string } ifelse
    % stack: arg1 arg2 new
    dup 0 4 index putinterval
    % stack: arg1 arg2 new
    dup 4 -1 roll length 4 -1 roll putinterval
    % stack: new
} bind def

/pr_str {
    %(in pr_str\n) print
    /obj exch def
    /arraytype obj type eq { % if list
        % accumulate an array of strings
        (\()
        obj length 0 gt { %if any elements
            [
                obj {
                    pr_str
                } forall
            ]
            { concatenate ( ) concatenate } forall
            dup length 1 sub 0 exch getinterval % strip off final space
        } if
        (\)) concatenate
    }{ /integertype obj type eq { % if number
        /slen obj 10 idiv 1 add def
        obj 10 slen string cvrs
    }{ /stringtype obj type eq { % if string
        (") obj (") concatenate concatenate
    }{ null obj eq { % if nil
        (nil)
    }{ true obj eq { % if true
        (true)
    }{ false obj eq { % if false
        (false)
    }{ /nametype obj type eq { % if symbol
        obj obj length string cvs
    }{
        (<unknown>) 
    } ifelse } ifelse } ifelse } ifelse } ifelse } ifelse } ifelse

    %(pr_str2 stack vvv\n) print
    %pstack
    %(pr_str2 stack ^^^\n) print
} def
